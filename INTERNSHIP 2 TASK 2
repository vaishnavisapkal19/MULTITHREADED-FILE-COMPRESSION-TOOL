#include <iostream>
#include <fstream>
#include <vector>
#include <thread>
#include <chrono>
#include <zlib.h>
#include <mutex>

constexpr size_t CHUNK_SIZE = 1024 * 1024;

std::mutex io_mutex;

struct Chunk {
    std::vector<unsigned char> input;
    std::vector<unsigned char> output;
    size_t compressed_size;
};


void compress_chunk(Chunk& chunk) {
    uLongf destLen = compressBound(chunk.input.size());
    chunk.output.resize(destLen);

    int res = compress(chunk.output.data(), &destLen, chunk.input.data(), chunk.input.size());
    if (res != Z_OK) {
        std::cerr << "Compression failed with error: " << res << std::endl;
        return;
    }

    chunk.output.resize(destLen);
    chunk.compressed_size = destLen;
}


void decompress_chunk(Chunk& chunk, size_t original_size) {
    chunk.output.resize(original_size);

    uLongf destLen = original_size;
    int res = uncompress(chunk.output.data(), &destLen, chunk.input.data(), chunk.input.size());

    if (res != Z_OK) {
        std::cerr << "Decompression failed with error: " << res << std::endl;
        return;
    }
}

void read_file_chunks(const std::string& filename, std::vector<Chunk>& chunks) {
    std::ifstream file(filename, std::ios::binary);

    while (!file.eof()) {
        Chunk chunk;
        chunk.input.resize(CHUNK_SIZE);
        file.read(reinterpret_cast<char*>(chunk.input.data()), CHUNK_SIZE);
        chunk.input.resize(file.gcount());

        if (!chunk.input.empty())
            chunks.push_back(std::move(chunk));
    }
}

void write_compressed_file(const std::string& filename, const std::vector<Chunk>& chunks) {
    std::ofstream file(filename, std::ios::binary);

    for (const auto& chunk : chunks) {
        uint32_t size = static_cast<uint32_t>(chunk.compressed_size);
        file.write(reinterpret_cast<const char*>(&size), sizeof(size));
        file.write(reinterpret_cast<const char*>(chunk.output.data()), chunk.compressed_size);
    }
}

void read_compressed_file(const std::string& filename, std::vector<Chunk>& chunks) {
    std::ifstream file(filename, std::ios::binary);

    while (file.peek() != EOF) {
        uint32_t size;
        file.read(reinterpret_cast<char*>(&size), sizeof(size));
        Chunk chunk;
        chunk.input.resize(size);
        file.read(reinterpret_cast<char*>(chunk.input.data()), size);
        chunks.push_back(std::move(chunk));
    }
}

void write_decompressed_file(const std::string& filename, const std::vector<Chunk>& chunks) {
    std::ofstream file(filename, std::ios::binary);

    for (const auto& chunk : chunks) {
        file.write(reinterpret_cast<const char*>(chunk.output.data()), chunk.output.size());
    }
}

template<typename Func>
void run_multithreaded(std::vector<Chunk>& chunks, Func func, size_t original_chunk_size = 0) {
    std::vector<std::thread> threads;
    for (auto& chunk : chunks) {
        threads.emplace_back([&chunk, func, original_chunk_size]() {
            func(chunk, original_chunk_size);
        });
    }

    for (auto& t : threads) {
        t.join();
    }
}

int main() {
    std::string input_file = "testfile.txt";
    std::string compressed_file = "testfile.z";
    std::string decompressed_file = "testfile_out.txt";

    
    std::vector<Chunk> chunks;
    read_file_chunks(input_file, chunks);

    
    auto start = std::chrono::high_resolution_clock::now();
    run_multithreaded(chunks, [](Chunk& c, size_t) { compress_chunk(c); });
    auto end = std::chrono::high_resolution_clock::now();

    std::cout << "Compression Time: "
              << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count()
              << " ms\n";

    write_compressed_file(compressed_file, chunks);

    
    std::vector<Chunk> compressed_chunks;
    read_compressed_file(compressed_file, compressed_chunks);

    
    start = std::chrono::high_resolution_clock::now();
    run_multithreaded(compressed_chunks, [](Chunk& c, size_t s) { decompress_chunk(c, s); }, CHUNK_SIZE);
    end = std::chrono::high_resolution_clock::now();

    std::cout << "Decompression Time: "
              << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count()
              << " ms\n";

    write_decompressed_file(decompressed_file, compressed_chunks);

    std::cout << "Done.\n";
    return 0;
}
